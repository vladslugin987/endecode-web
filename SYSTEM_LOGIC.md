# Система водяных знаков для медиафайлов - Техническая документация

## Обзор системы

Система представляет собой комплексное решение для защиты медиафайлов с использованием трех типов водяных знаков:

1. **Скрытые текстовые водяные знаки** - добавляются в конец текстовых файлов
2. **Невидимые бинарные водяные знаки** - встраиваются в медиафайлы (изображения, видео)  
3. **Видимые водяные знаки** - полупрозрачный текст на изображениях

### Основная цель
Пакетная обработка папок с файлами для создания защищенных копий с уникальными идентификаторами.

## Архитектура системы

```
BatchUtils (Координатор)
    ├── FileUtils (Файловые операции)
    ├── EncodingUtils (Текстовые водяные знаки)
    ├── WatermarkUtils (Бинарные водяные знаки)  
    ├── ImageUtils (Видимые водяные знаки)
    └── ConsoleState (Логирование)
```

## Компоненты системы

### 1. BatchUtils.kt - Главный координатор

**Основная функция:** `performBatchCopyAndEncode()`

**Алгоритм обработки:**
1. **Подготовка:** 
   - Создание папки `{SourceFolder}-Copies`
   - Извлечение стартового номера из baseText
   - Расчет общего количества операций для прогресса

2. **Первый проход - Обработка:**
   ```
   Для каждой копии (i = 0 до numCopies):
     - Создать папку с номером (001, 002, 003...)
     - Скопировать исходную папку
     - Обработать файлы (скрытые водяные знаки)
     - Добавить видимые водяные знаки (если включено)
     - Выполнить swap операцию (если включено)
   ```

3. **Второй проход - ZIP архивация:**
   ```
   Если createZip = true:
     Для каждой обработанной папки:
       - Создать ZIP архив без сжатия
       - Удалить исходную папку
   ```

**Swap операция:**
- Находит файл с номером N и файл с номером N+10
- Меняет их местами через временный файл
- Используется для дополнительной защиты

### 2. EncodingUtils.kt - Текстовые водяные знаки

**Алгоритм шифрования - Caesar Cipher с shift = 7:**
```kotlin
Для каждого символа:
  - Заглавные буквы: (char - 'A' + 7) % 26 + 'A'
  - Строчные буквы: (char - 'a' + 7) % 26 + 'a'  
  - Цифры: (digit + 7) % 10
  - Остальные символы: без изменений
```

**Пример шифрования:**
- "Test 123" → "Alzk 890"

**Форматы водяных знаков:**
- **Новый формат:** `<<==[зашифрованный текст]==>`
- **Старый формат:** `*/[зашифрованный текст]`

**Процесс добавления в файл:**
```kotlin
processFile(file, watermark):
  1. Читать содержимое файла
  2. Проверить наличие водяного знака
  3. Если отсутствует - добавить в конец файла
  4. Логировать результат
```

### 3. WatermarkUtils.kt - Бинарные водяные знаки

**Формат бинарного водяного знака:**
```
[WATERMARK_START]<<==[WATERMARK_END]==>>
```

**Константы:**
- `WATERMARK_START = "<<=="` (4 байта)
- `WATERMARK_END = "==>>"` (4 байта)  
- `MAX_WATERMARK_LENGTH = 100` байт

**Алгоритм добавления:**
```kotlin
addWatermark(file, encodedText):
  1. Проверить наличие существующего водяного знака
  2. Открыть файл в режиме записи
  3. Перейти в конец файла
  4. Записать: WATERMARK_START + encodedText + WATERMARK_END
```

**Алгоритм поиска:**
```kotlin
findWatermark(data):
  1. Прочитать последние 100 байт файла
  2. Найти WATERMARK_START (поиск с конца)
  3. Найти WATERMARK_END после найденного START
  4. Извлечь содержимое между маркерами
```

**Алгоритм удаления:**
```kotlin
removeWatermarkFromFile(file):
  1. Найти позицию водяного знака
  2. Обрезать файл до этой позиции
  3. Сохранить изменения
```

### 4. ImageUtils.kt - Видимые водяные знаки

**Использует OpenCV для обработки изображений**

**Поддерживаемые позиции:**
- `TOP_LEFT` - верхний левый угол
- `TOP_RIGHT` - верхний правый угол
- `CENTER` - центр изображения
- `BOTTOM_LEFT` - нижний левый угол  
- `BOTTOM_RIGHT` - нижний правый угол (по умолчанию)

**Алгоритм добавления текста:**
```kotlin
addTextToImage(imageFile, text, position):
  1. Загрузить изображение через OpenCV
  2. Настроить параметры текста:
     - Шрифт: FONT_HERSHEY_SIMPLEX
     - Размер: 0.4
     - Толщина: 1
     - Прозрачность: 50%
     - Цвет: белый (255,255,255)
  3. Вычислить размер текста и позицию
  4. Создать overlay слой с текстом
  5. Смешать с основным изображением (alpha blending)
  6. Сохранить результат
```

### 5. FileUtils.kt - Файловые операции

**Поддерживаемые форматы:**
```kotlin
supportedExtensions = [
  "txt",           // Текстовые файлы
  "jpg", "jpeg", "png",  // Изображения
  "mp4", "avi", "mov", "mkv"  // Видео
]

videoExtensions = [
  "mp4", "avi", "mov", "mkv"
]
```

**Основные функции:**
- `copyDirectory()` - асинхронное копирование папок
- `getSupportedFiles()` - рекурсивный поиск поддерживаемых файлов
- `countFiles()` - подсчет файлов для прогресс-бара
- `isImageFile()` / `isVideoFile()` - определение типа файла

### 6. ConsoleState.kt - Управление логами

**Архитектура для Compose UI:**
```kotlin
object ConsoleState {
    private val _logs = mutableStateListOf<String>()  // Reactive state
    val logs: SnapshotStateList<String> = _logs       // Read-only access
    
    fun log(message: String): добавить лог + print в консоль
    fun clear(): очистить все логи
}
```

## Потоки обработки данных

### Поток 1: Обработка текстовых файлов
```
Текстовый файл (.txt)
    ↓
EncodingUtils.processFile()
    ↓
1. Читать содержимое
2. Создать водяной знак: <<==[зашифрованный baseText + orderNumber]==>>
3. Добавить в конец файла
    ↓
Защищенный файл
```

### Поток 2: Обработка видеофайлов
```
Видеофайл (.mp4, .avi, .mov, .mkv)
    ↓
WatermarkUtils.addWatermark()
    ↓
1. Проверить наличие водяного знака
2. Зашифровать текст (baseText + orderNumber) 
3. Добавить в конец: <<==[зашифрованный текст]==>>
    ↓
Защищенное видео
```

### Поток 3: Обработка изображений
```
Изображение (.jpg, .jpeg, .png)
    ↓
1. EncodingUtils.processFile() - скрытый текстовый водяной знак
2. WatermarkUtils.addWatermark() - невидимый бинарный водяной знак  
3. ImageUtils.addTextToImage() - видимый водяной знак (опционально)
    ↓
Трижды защищенное изображение
```

## Примеры данных

### Пример входных параметров:
```kotlin
performBatchCopyAndEncode(
    sourceFolder = File("/path/to/Photos-Bundle"),
    numCopies = 5,
    baseText = "Project Alpha 001",
    addSwap = true,
    addWatermark = true,
    createZip = true,
    watermarkText = "CONFIDENTIAL",
    photoNumber = 3
)
```

### Результирующая структура:
```
Photos-Bundle-Copies/
├── 001/
│   └── Photos-Bundle.zip    // Содержит обработанные файлы
├── 002/
│   └── Photos-Bundle.zip
├── 003/
│   └── Photos-Bundle.zip
├── 004/
│   └── Photos-Bundle.zip
└── 005/
    └── Photos-Bundle.zip
```

### Пример водяных знаков:

**Текстовый файл (скрытый):**
```
[Исходное содержимое файла]
<<==[зашифрованный "Project Alpha 001"]==>>
```

**Изображение/видео (бинарный):**
```
[Исходные байты файла]<<==Wyvqlua Hswoh 008==>>
```

**Изображение (видимый):**
Полупрозрачный текст "CONFIDENTIAL" в правом нижнем углу.

### Пример шифрования:
```
Исходный текст: "Project Alpha 001"
Зашифрованный: "Wyvqlua Hswoh 008"

P(15) + 7 = W(22)
r(17) + 7 = y(24)  
o(14) + 7 = v(21)
и т.д.
```

### Swap операция пример:
```
До swap:
- Photo-001.jpg
- Photo-011.jpg  

После swap:
- Photo-001.jpg (содержит данные бывшего Photo-011.jpg)
- Photo-011.jpg (содержит данные бывшего Photo-001.jpg)
```

## Безопасность и восстановление

### Извлечение водяных знаков:
```kotlin
// Из текстового файла
EncodingUtils.extractWatermark(fileContent)

// Из бинарного файла  
WatermarkUtils.extractWatermarkText(file)
```

### Расшифровка:
```kotlin
EncodingUtils.decodeText(encryptedText)
```

### Удаление водяных знаков:
```kotlin
WatermarkUtils.removeWatermarks(directory) { progress ->
    // Обновление прогресса
}
```

## Особенности реализации

1. **Асинхронность:** Все операции с файлами выполняются в `Dispatchers.IO`
2. **Обработка ошибок:** Каждая операция обернута в try-catch с логированием
3. **Прогресс:** Детальное отслеживание прогресса для UI
4. **Память:** Использование `RandomAccessFile` для эффективной работы с большими файлами
5. **ZIP без сжатия:** `ZipOutputStream.STORED` для быстрого создания архивов
6. **Фильтрация служебных файлов:** Исключение `.DS_Store`, `__MACOSX` из ZIP

## Технические ограничения

- Максимальная длина водяного знака: 100 байт
- Поддержка только UTF-8 кодировки
- OpenCV требует инициализации для работы с изображениями
- Swap работает только с файлами, имеющими числовые суффиксы в имени